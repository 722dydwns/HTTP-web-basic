## **🟦 섹션 8. HTTP 헤더2 - 캐시와 조건부 요 청**

### **캐시란?**

- 클라이언트가 서버에 요청하는 자원은 단순 text부터 이미지, 영상, 파일까지 다양하다. 그 중에서는 용량이 커서 큰 네트워크 비용을 부담해야 하는 자원들이 있고, 변경 가능성이 잦지 않은 자원들이 있다.
- 이런 자원들을 매 요청 시마다 새로 다운받는 것이 큰 비용 부담이므로 ‘캐시’를 활용한다.
- **자원은 우선 ‘브라우저 캐시’에 저장해두고, 해당 자원이 변경되지 않았다면, 서버에서 다운받지 않고 ‘브라우저 캐시’에 저장해놓은 자원을 다시 사용한다는 개념이다.**

### **⬛ 1. 캐시 기본 동작**

**◼️ 캐시가 없을 때** 

예를 들어 클라이언트가 GET/star.jpg 요청을 연속해서 두 번 했다고 가정해보자.

**[첫 번째 요청] 시, 서버는 해당 요청에 맞는 응답을 http로 보낸다.**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2aaace0-24ef-4ae8-bed4-d8cb2e34acd9/cceff3f4-0f69-4afa-a59f-8fae852876cf/Untitled.png)

**[두 번째 요청] 시, 서버는 또 똑같이 해당 요청에 맞는 응답을 http로 보낸다.**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2aaace0-24ef-4ae8-bed4-d8cb2e34acd9/c031adc0-65c1-4156-85eb-e5d9b72efecc/Untitled.png)

### **🟦 캐시 없는 상황 - 비효율적**

**캐시가 없는 상황에서는 위 그림처럼 똑같은 요청을 두 번 이상 요청해도, 똑같은 작업을 매번 해야 한다. → 비효율적이다 → 캐시 필요성**

- 데이터 변경 없어도 계속해서 네트워크를 통해 데이터를 다운로드 받아야 한다.
- 인터넷 네트워크는 매우 느리고 비싸다
- 브라우저 로딩 속도가 느리다.
- 느린 사용자 경험

**◼️ 캐시 적용**

**1) 캐시를 적용하면 첫 요청의 응답 결과를 웹 브라우저가 유효 시간 동안 내부의 브라우저 캐시 저장소에 저장해둔다.**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2aaace0-24ef-4ae8-bed4-d8cb2e34acd9/242f42ba-142c-4a75-88a2-21adb19131cf/Untitled.png)

**2) 이후 두 번째 요청에서는 우선 ‘브라우저 캐시 저장소’를 먼저 뒤진다.** 

- 캐시 유효 시간 이내의 요청에 대해서 캐시저장소에 있는 데이터를 먼저 가져다 쓴다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2aaace0-24ef-4ae8-bed4-d8cb2e34acd9/4a88f517-6c98-4491-a456-01671fb9a867/Untitled.png)

### **🟦 캐시 적용 - 효율**

- 캐시 덕분에 캐시 유효 시간 동안은 같은 요청에 대한 자원을 위해 불필요하게 네트워크를 사용할 필요가 없어진다.
- 비싼 네트워크 사용량을 줄일 수 있다.
- 브라우저 로딩 속도가 매우 빠르다.
- 빠른 사용자 경험

**◼️ 캐시 유효 시간 초과 후의 요청 시, 다시 서버로부터 데이터를 조회하고 캐시 갱신한다.**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2aaace0-24ef-4ae8-bed4-d8cb2e34acd9/3f87de2b-d2c3-4594-b82b-499867b4ad99/Untitled.png)

- 기존 캐시 저장소에 있던 데이터는 유효 시간이 지났으므로 다시 서버에 요청을 하고 해당 응답 결과를 다시 캐시에 저장해두고 유효 시간을 갱신시킨다.
- 즉, 캐시 유효시간이 초과하면, 서버를 통해 데이터를 다시 조회하고 캐시를 갱신한다.
- 이때 다시 네트워크 다운로드가 발생한다.

⇒ **그런데, 유효 시간이 지났어도 변경점 없는 데이터를 다시 조회하기 위해 불필게 네트워크를 탈 필요가 있을까 ? 해결책이 있다!**

 ****

### **⬛ 2. 검증 헤더와 조건부 요청 1**

**◼️ 캐시 시간 초과** 

- 캐시 유효 시간 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타난다.

**1) 서버에서 기존 데이터를 변경함** 

**2) 서버에서 기존 데이터를 변경하지 않음** 

**◼️ 검증 헤더와 조건부 요청** 

캐시 만료 후에도 서버에서 데이터를 변경하지 않은 경우, 다시 서버로부터 데이터를 전송받는 대신에 저장해 두었던 캐시를 재사용 할 수 있다.

- **단 , 클라이언트의 데이터와 서버 데이터가 ‘같다’는 사실 확인 방법 필요!**

**→ 그게 검증 헤더와 조건부 요청 이다.**  

🟦 **검증 헤더 추가 - 첫 번째 요청** 

데이터가 마지막에 수정된 시간 : **Last Modified (검증 헤더)**

응답 결과를 캐시에 저장하는데, 이때 데이터 최종 수정일 Last Modified를 함께 기록 

🟦 **검증 헤더 추가 - 두 번째 요청** 

캐시가 가지고 있는 데이터 최종 수정일이 있다면 확인 후 서버에 함께 보냄

서버는 해당 데이터 최종 수정일을 **(if-modified-since)** **조건부 요청** 확인해보니, 서버의 데이터 최종 수정일과 동일함을 확인 | 변경점 X 

**→ 수정 안되면 HTTP/1.1 304 Not Modified 보냄 - Http Body가 없음**

→ 네트워크 부하가 확 줄어든다. 

→ 304 Modified를 받았으면 캐시를 다시 재사용한다.

**◼️ 검증 헤더와 조건부 요청 정리**

- **캐시 유효 시간 초과해도, 서버 데이터가 갱신되지 않으면 304 Not Modified + 헤더 메타 정보만 응답한다 (바디 X)**
- 클라이언트는 서버가 보낸 응답 헤더 정보로만 캐시 메타 정보를 갱신
- 클라이언트는 캐시에 저장되어 있는 데이터 재활용
- 결과적으로 네트워크 다운로드가 발생하지만 용량 적은 헤더 정보만 다운로드
- 매우 실용적인 해결책

 ****

### **⬛ 검증 헤더와 조건부 요청**

**◼️ 검증 헤더** 

- 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
- Last-Modified, ETag

**◼️ 조건부 요청 헤더** 

- 검증 헤더로 조건에 따른 분기
- if-Modified-Since : Last-Modified 사용
- if-None-Match : ETag 사용
- 조건이 만족하면 200 OK
- 조건이 만족하지 않았으면 304 Not Modified

**🟦 if-Modified-Since : 이후에 데이터가 수정되었다면 ?** 

**◼️ 데이터 미변경 예시** 

- 캐시 : 2020년 11월 10일 10:00:00 vs 서버 : 2020년 11월 10일 10:00:00
- **시간 똑같음 → 304 Not Modified 헤더 데이터만 전송 (Body 미포함)**
- 전송 용량 0.1M (헤더 0.1M, 바디 1.0M)

**◼️ 데이터 변경 예시** 

- 캐시 : 2020년 11월 10일 10:00:00 vs 서버 : 2020년 11월 10일 **11:00:00**
- **시간 다름 → 200 OK, 모든 데이터 전송 (Body 포함)**
- 전송 용량 : 1.1M  (헤더 0.1M, 바디 1.0M)

**◼️ Last-Modified, If-Modified-Since 의 단점**

- 1초 미만 (0.x초) 단위로 캐시 조정 불가능
- 날짜 기반 로직 사용
- 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우

ex) 스페이스나 주석처럼 크게 영향 없는 변경에서 캐시 유지하고 싶은 경우

### **⬛ ETag, If-None-Match**

**◼️ ETag (Entity Tag)**

- 캐시용 데이터에 임의의 고유 버전 이름을 달아둠

ex) ETag : “v1.0”,  ETag: “a2jioerj13”

- 데이터가 변경되면 이 이름을 바꾸어 변경함(Hash 다시 생성)

ex) ETag : “aaaa” → ETag : “bbbb”

- 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기

**◼️ ETag 활용한 경우** 

- 시간이 초과되어도 캐시가 가지고 있는 **ETag 확인한 뒤** 수정된 건지 아닌지 확인하여 재사용 여부를 결정하면 된다.

**◼️ ETag, If-None-Match 정리** 

- 진짜 단순하게 ETag만 서버에 보내서 같으면 유지, 다르면 다시 받기
- 캐시 제어 로직을 서버에서 완전히 관리
- 클라이언트는 단순히 이 값을 서버에 제공하는 역할만

**예) 서버는 배타 오픈 기간인 3일 동안 파일 변경되어도 ETag를 동일하게 유지**

**예) 애플리케이션 배포 주기에 맞춰서 ETag 모두 갱신!**

### **⬛ 3. 캐시와 조건부 요청 헤더**

**◼️ 캐시 제어 헤더** 

Cache-Control : 캐시 제어

Pragma : 캐시 제어 (하위 호환)

Expires : 캐시 유효 기간 (하위 호환)

**◼️ Cache-Control : 캐시 지시어**

- Cache-Control : **max-age** | 캐시 유효 시간, 초단위
- Cache-Control: **no-cache** | 데이터는 캐시해도 되지만, 항상 orogin서버에 검증하고 사용해라
- Cache-Control: **no-store** | 데이터에 민감한 정보가 있으므로 저장하면 안됨 (메모리에서 사용하고 최대한 빨리 삭제)

**◼️ Pragma : 캐시 제어 (하위호환)**

**◼️ Expires | 캐시 만료일 지정 (하위 호환)**

- 캐시 만료일을 정확한 날짜로 지정
- HTTP 1.0 부터 사용
- 지금은 더 유연한 Cache-Control:max-age 권장
- 만약 max-age와 expires 함께 사용 시, expires 무시함

**◼️ 검증 헤더와 조건부 요청 헤더**

- **검증 헤더 (validator)**

ETag: “v1.0”, ETag : “adkfa21”

- **조건부 요청 헤더**

if-Math, if-None-Math : ETag 값 사용 

if-Modified-Since, If-Unmodified-Since : Last-Modified 값 사용
